1. IBuilder (Database, Build)
7. Join options / INNER / LEFT / RIGHT 

Barteco/Norman 
Norman Framework is nextgen object/relational mapper aiming .NET family, rethinking application management experience, when overload rapidly kills performance of your database

#region ExecutePending(Async)

        // TODO: every time Query/Insert/Update/Delete is built, it is added to list below. When statement is executed, it is removed from this list. When ExecutePending is called, all statements here are executed, and results are attached to new Result property of its statement, list is cleared

        private List<IExecutableStatement> _pendingStatements;

        public void ExecutePending()
        {
            
        }

        public async Task ExecutePendingAsync()
        {

        }

        #endregion
		


AssemblySourceConvention
	IEnumerable<Assembly> Run(Assembly databaseAssembly)
	{
		yield return databaseAssembly;
	}

List<IConfigurationDiscoverConvention> 
	IEnumerable<IConfiguration> Run(Assembly assembly)

	EntityConfigrationDiscoveryConvention
	ViewConfigrationDiscoveryConvention
	FunctionConfigrationDiscoveryConvention
	StoredProcedureConfigrationDiscoveryConvention

DefaultSchemaConvention
TableNamingConvention
ColumnNamingConvention
ColumnTypeMappingConvention



1. ISourceGenerator -> scans for db context, executes OnConfiguring method to discover all entity/view/sp/fn, then builds a model class, which is compiled and used at runtime, but not attached to source code. When we run `dotnet croco add migration sdsf`, another model is generated, but then it is persisted is SC as current state. When we run application, we can compare hash codes of both this models to determine any changes were made and another migration to sync models is needed


public class MyDatabaseSchemaModel
{
	// IReadOnlyDictionary
	public List<TableModel> Tables { get; } = new List<TableModel> 
	{
		new TableModel(typeof(Product))
		{
			Schema = "",
			Name = "",
			Columns = new List<Column> 
			{
				new Column("_id", "Id", "int"),
				new Column("_name", "Name", "nvarchar(max)")
			},
			PrimaryKeys = new List<PrimaryKey> { new PrimaryKeyModel("_id", "Id", "int", autogenerated: true) },
			ForeignKeys = new List<ForeignKey> { },
			Indexes = new List<Index> { }
		}
	}

	public List<StoredProcedure> StoredProcedures { get; }

	public List<Function> Functions { get; }

	public List<View> Views { get; }
}

namespace X
{
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }

        public ICollection<string> Items { get; set; }

        public Product(string name)
        {
            Name = name;
        }
    }

    public enum ProxyState
    {
        Unmodified,
        Added,
        Modified,
        Removed
    }

    public class ChangeTracker
    {
        private Dictionary<string, (object From, object To)> _changes;
        private ProxyState __state;

        public bool HasChanges => _changes.Count > 0;

        public void AddChange(string column, object from, object to)
        {
            if (_changes.ContainsKey(column))
            {
                if (_changes[column].From.Equals(to))
                {
                    _changes.Remove(column);
                }
                else
                {
                    _changes[column] = (_changes[column].From, to);
                }
            }
            else
            {
                _changes.Add(column, (from, to));
            }
        }


    }

    [System.Diagnostics.DebuggerDisplay("overrite to be visible as product of copy if defined in product")]
    [System.Diagnostics.DebuggerStepThrough] // ?
    public class Product_StaticProxy_Guid
    {
        private Product __entity;
        private ChangeTracker __tracker = new ChangeTracker();

        public int Id
        {
            get
            {
                return __entity.Id;
            }
            set
            {
                if (!__entity.Id.Equals(value))
                {
                    __tracker.AddChange("Id", __entity.Id, value);
                }
                __entity.Id = value;
            }
        }

        public string Name
        {
            get
            {
                return __entity.Name;
            }
            set
            {
                if (!__entity.Name.Equals(value))
                {
                    __tracker.AddChange("Name", __entity.Name, value);
                }
                __entity.Name = value;
            }
        }

        private CollectionTracker<string> __items;
        public ICollection<string> Items
        {
            get
            {
                return __items;
            }
            set
            {
                __items.Clear();

                foreach (var item in value)
                {
                    __items.Add(item);
                }
            }
        }

        public Product_StaticProxy_Guid(Product entity)
        {
            __entity = entity;
            __items = new CollectionTracker<string>(__entity.Items);
        }

        public static implicit operator Product(Product_StaticProxy_Guid me)
        {
            return me.__entity;
        }
    }

    public struct CollectionTracker<T> : ICollection<T>
    {
        private readonly ICollection<T> _collection;

        public CollectionTracker(ICollection<T> collection)
        {
            _collection = collection;
        }

        public int Count => _collection.Count;

        public bool IsReadOnly => _collection.IsReadOnly;

        public void Add(T item)
        {
            _collection.Add(item);
        }

        public void Clear()
        {
            _collection.Clear();
        }

        public bool Contains(T item)
        {
            return _collection.Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            _collection.CopyTo(array, arrayIndex);
        }

        public IEnumerator<T> GetEnumerator()
        {
            return _collection.GetEnumerator();
        }

        public bool Remove(T item)
        {
            return _collection.Remove(item);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IEnumerable)_collection).GetEnumerator();
        }
    }

    public class Test
    {
        public Test()
        {
            //using var scope = _context.CreateEditableScope());
            //_context.From<Product>().ToListQuery().AsTrackable().ExecuteAsync();


            var prod = new List<Product>();

            prod.Add(new Product("x"));
            prod.Add(new Product_StaticProxy_Guid("x"));
        }
    }
}

Run code
1. Scan database
2. Build schema model with hash
3. Check if model already exists
	3.1. If not, throw SchemaUninitializedException
	3.1. If yes, but hashes dont match, throw SchemaOutOfDateException 
	

3.1. Compare hashes of schema models
		3.1.1. Detect diff
		3.1.2. Generate migration
4. Add/update model it as persistent file with hash


